{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.preventScroll = exports.GridCell = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _styledComponents = _interopRequireDefault(require(\"styled-components\"));\nvar _add_minutes = _interopRequireDefault(require(\"date-fns/add_minutes\"));\nvar _add_hours = _interopRequireDefault(require(\"date-fns/add_hours\"));\nvar _add_days = _interopRequireDefault(require(\"date-fns/add_days\"));\nvar _start_of_day = _interopRequireDefault(require(\"date-fns/start_of_day\"));\nvar _is_same_minute = _interopRequireDefault(require(\"date-fns/is_same_minute\"));\nvar _format = _interopRequireDefault(require(\"date-fns/format\"));\nvar _typography = require(\"./typography\");\nvar _colors = _interopRequireDefault(require(\"./colors\"));\nvar _selectionSchemes = _interopRequireDefault(require(\"./selection-schemes\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n// Import only the methods we need from date-fns in order to keep build size small\nconst Wrapper = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__Wrapper\",\n  componentId: \"sc-1ke4ka2-0\"\n})([\"display:flex;align-items:center;width:100%;user-select:none;\"]);\nconst Grid = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__Grid\",\n  componentId: \"sc-1ke4ka2-1\"\n})([\"display:grid;grid-template-columns:auto repeat(\", \",1fr);grid-template-rows:auto repeat(\", \",1fr);column-gap:\", \";row-gap:\", \";width:100%;\"], props => props.columns, props => props.rows, props => props.columnGap, props => props.rowGap);\nconst GridCell = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__GridCell\",\n  componentId: \"sc-1ke4ka2-2\"\n})([\"place-self:stretch;touch-action:none;\"]);\nexports.GridCell = GridCell;\nconst DateCell = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__DateCell\",\n  componentId: \"sc-1ke4ka2-3\"\n})([\"width:100%;height:25px;background-color:\", \";&:hover{background-color:\", \";}\"], props => props.selected ? props.selectedColor : props.unselectedColor, props => props.hoveredColor);\nconst DateLabel = (0, _styledComponents.default)(_typography.Subtitle).withConfig({\n  displayName: \"ScheduleSelector__DateLabel\",\n  componentId: \"sc-1ke4ka2-4\"\n})([\"@media (max-width:699px){font-size:12px;}margin:0;margin-bottom:4px;\"]);\nconst TimeText = (0, _styledComponents.default)(_typography.Text).withConfig({\n  displayName: \"ScheduleSelector__TimeText\",\n  componentId: \"sc-1ke4ka2-5\"\n})([\"@media (max-width:699px){font-size:10px;}text-align:right;margin:0;margin-right:4px;\"]);\nconst preventScroll = e => {\n  e.preventDefault();\n};\nexports.preventScroll = preventScroll;\nclass ScheduleSelector extends React.Component {\n  // documentMouseUpHandler: () => void = () => {}\n  // endSelection: () => void = () => {}\n  // handleTouchMoveEvent: (event: React.SyntheticTouchEvent<*>) => void\n  // handleTouchEndEvent: () => void\n  // handleMouseUpEvent: (date: Date) => void\n  // handleMouseEnterEvent: (date: Date) => void\n  // handleSelectionStartEvent: (date: Date) => void\n  static getDerivedStateFromProps(props, state) {\n    // As long as the user isn't in the process of selecting, allow prop changes to re-populate selection state\n    if (state.selectionStart == null) {\n      return {\n        selectionDraft: [...props.selection],\n        dates: ScheduleSelector.computeDatesMatrix(props)\n      };\n    }\n    return null;\n  }\n  static computeDatesMatrix(props) {\n    const startTime = (0, _start_of_day.default)(props.startDate);\n    const dates = [];\n    const minutesInChunk = Math.floor(60 / props.hourlyChunks);\n    for (let d = 0; d < props.numDays; d += 1) {\n      const currentDay = [];\n      for (let h = props.minTime; h < props.maxTime; h += 1) {\n        for (let c = 0; c < props.hourlyChunks; c += 1) {\n          currentDay.push((0, _add_minutes.default)((0, _add_hours.default)((0, _add_days.default)(startTime, d), h), c * minutesInChunk));\n        }\n      }\n      dates.push(currentDay);\n    }\n    return dates;\n  }\n  constructor(props) {\n    super(props);\n    this.cellToDate = new Map();\n    this.gridRef = null;\n    this.renderDateCellWrapper = time => {\n      const startHandler = () => {\n        this.handleSelectionStartEvent(time);\n      };\n      const selected = Boolean(this.state.selectionDraft.find(a => (0, _is_same_minute.default)(a, time)));\n      return /*#__PURE__*/React.createElement(GridCell, {\n        className: \"rgdp__grid-cell\",\n        role: \"presentation\",\n        key: time.toISOString() // Mouse handlers\n        ,\n\n        onMouseDown: startHandler,\n        onMouseEnter: () => {\n          this.handleMouseEnterEvent(time);\n        },\n        onMouseUp: () => {\n          this.handleMouseUpEvent(time);\n        } // Touch handlers\n        // Since touch events fire on the event where the touch-drag started, there's no point in passing\n        // in the time parameter, instead these handlers will do their job using the default Event\n        // parameters\n        ,\n\n        onTouchStart: startHandler,\n        onTouchMove: this.handleTouchMoveEvent,\n        onTouchEnd: this.handleTouchEndEvent\n      }, this.renderDateCell(time, selected));\n    };\n    this.renderDateCell = (time, selected) => {\n      const refSetter = dateCell => {\n        if (dateCell) {\n          this.cellToDate.set(dateCell, time);\n        }\n      };\n      if (this.props.renderDateCell) {\n        return this.props.renderDateCell(time, selected, refSetter);\n      } else {\n        return /*#__PURE__*/React.createElement(DateCell, {\n          selected: selected,\n          ref: refSetter,\n          selectedColor: this.props.selectedColor,\n          unselectedColor: this.props.unselectedColor,\n          hoveredColor: this.props.hoveredColor\n        });\n      }\n    };\n    this.renderTimeLabel = time => {\n      if (this.props.renderTimeLabel) {\n        return this.props.renderTimeLabel(time);\n      } else {\n        return /*#__PURE__*/React.createElement(TimeText, null, (0, _format.default)(time, this.props.timeFormat));\n      }\n    };\n    this.renderDateLabel = date => {\n      if (this.props.renderDateLabel) {\n        return this.props.renderDateLabel(date);\n      } else {\n        return /*#__PURE__*/React.createElement(DateLabel, null, (0, _format.default)(date, this.props.dateFormat));\n      }\n    };\n    this.state = {\n      selectionDraft: [...this.props.selection],\n      // copy it over\n      selectionType: null,\n      selectionStart: null,\n      isTouchDragging: false,\n      dates: ScheduleSelector.computeDatesMatrix(props)\n    };\n    this.selectionSchemeHandlers = {\n      linear: _selectionSchemes.default.linear,\n      square: _selectionSchemes.default.square\n    };\n    this.endSelection = this.endSelection.bind(this);\n    this.handleMouseUpEvent = this.handleMouseUpEvent.bind(this);\n    this.handleMouseEnterEvent = this.handleMouseEnterEvent.bind(this);\n    this.handleTouchMoveEvent = this.handleTouchMoveEvent.bind(this);\n    this.handleTouchEndEvent = this.handleTouchEndEvent.bind(this);\n    this.handleSelectionStartEvent = this.handleSelectionStartEvent.bind(this);\n  }\n  componentDidMount() {\n    // We need to add the endSelection event listener to the document itself in order\n    // to catch the cases where the users ends their mouse-click somewhere besides\n    // the date cells (in which case none of the DateCell's onMouseUp handlers would fire)\n    //\n    // This isn't necessary for touch events since the `touchend` event fires on\n    // the element where the touch/drag started so it's always caught.\n    document.addEventListener('mouseup', this.endSelection); // Prevent page scrolling when user is dragging on the date cells\n\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.addEventListener) {\n        // @ts-ignore\n        dateCell.addEventListener('touchmove', preventScroll, {\n          passive: false\n        });\n      }\n    });\n  }\n  componentWillUnmount() {\n    document.removeEventListener('mouseup', this.endSelection);\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.removeEventListener) {\n        // @ts-ignore\n        dateCell.removeEventListener('touchmove', preventScroll);\n      }\n    });\n  } // Performs a lookup into this.cellToDate to retrieve the Date that corresponds to\n  // the cell where this touch event is right now. Note that this method will only work\n  // if the event is a `touchmove` event since it's the only one that has a `touches` list.\n\n  getTimeFromTouchEvent(event) {\n    const {\n      touches\n    } = event;\n    if (!touches || touches.length === 0) return null;\n    const {\n      clientX,\n      clientY\n    } = touches[0];\n    const targetElement = document.elementFromPoint(clientX, clientY);\n    if (targetElement) {\n      const cellTime = this.cellToDate.get(targetElement);\n      return cellTime !== null && cellTime !== void 0 ? cellTime : null;\n    }\n    return null;\n  }\n  endSelection() {\n    this.props.onChange(this.state.selectionDraft);\n    this.setState({\n      selectionType: null,\n      selectionStart: null\n    });\n  } // Given an ending Date, determines all the dates that should be selected in this draft\n\n  updateAvailabilityDraft(selectionEnd, callback) {\n    const {\n      selectionType,\n      selectionStart\n    } = this.state;\n    if (selectionType === null || selectionStart === null) return;\n    let newSelection = [];\n    if (selectionStart && selectionEnd && selectionType) {\n      newSelection = this.selectionSchemeHandlers[this.props.selectionScheme](selectionStart, selectionEnd, this.state.dates);\n    }\n    let nextDraft = [...this.props.selection];\n    if (selectionType === 'add') {\n      nextDraft = Array.from(new Set([...nextDraft, ...newSelection]));\n    } else if (selectionType === 'remove') {\n      nextDraft = nextDraft.filter(a => !newSelection.find(b => (0, _is_same_minute.default)(a, b)));\n    }\n    this.setState({\n      selectionDraft: nextDraft\n    }, callback);\n  } // Isomorphic (mouse and touch) handler since starting a selection works the same way for both classes of user input\n\n  handleSelectionStartEvent(startTime) {\n    // Check if the startTime cell is selected/unselected to determine if this drag-select should\n    // add values or remove values\n    const timeSelected = this.props.selection.find(a => (0, _is_same_minute.default)(a, startTime));\n    this.setState({\n      selectionType: timeSelected ? 'remove' : 'add',\n      selectionStart: startTime\n    });\n  }\n  handleMouseEnterEvent(time) {\n    // Need to update selection draft on mouseup as well in order to catch the cases\n    // where the user just clicks on a single cell (because no mouseenter events fire\n    // in this scenario)\n    this.updateAvailabilityDraft(time);\n  }\n  handleMouseUpEvent(time) {\n    this.updateAvailabilityDraft(time); // Don't call this.endSelection() here because the document mouseup handler will do it\n  }\n  handleTouchMoveEvent(event) {\n    this.setState({\n      isTouchDragging: true\n    });\n    const cellTime = this.getTimeFromTouchEvent(event);\n    if (cellTime) {\n      this.updateAvailabilityDraft(cellTime);\n    }\n  }\n  handleTouchEndEvent() {\n    if (!this.state.isTouchDragging) {\n      // Going down this branch means the user tapped but didn't drag -- which\n      // means the availability draft hasn't yet been updated (since\n      // handleTouchMoveEvent was never called) so we need to do it now\n      this.updateAvailabilityDraft(null, () => {\n        this.endSelection();\n      });\n    } else {\n      this.endSelection();\n    }\n    this.setState({\n      isTouchDragging: false\n    });\n  }\n  renderFullDateGrid() {\n    const flattenedDates = [];\n    const numDays = this.state.dates.length;\n    const numTimes = this.state.dates[0].length;\n    for (let j = 0; j < numTimes; j += 1) {\n      for (let i = 0; i < numDays; i += 1) {\n        flattenedDates.push(this.state.dates[i][j]);\n      }\n    }\n    const dateGridElements = flattenedDates.map(this.renderDateCellWrapper);\n    for (let i = 0; i < numTimes; i += 1) {\n      const index = i * numDays;\n      const time = this.state.dates[0][i]; // Inject the time label at the start of every row\n\n      dateGridElements.splice(index + i, 0, this.renderTimeLabel(time));\n    }\n    return [/*#__PURE__*/\n    // Empty top left corner\n    React.createElement(\"div\", {\n      key: \"topleft\"\n    }),\n    // Top row of dates\n    ...this.state.dates.map((dayOfTimes, index) => /*#__PURE__*/React.cloneElement(this.renderDateLabel(dayOfTimes[0]), {\n      key: \"date-\".concat(index)\n    })),\n    // Every row after that\n    ...dateGridElements.map((element, index) => /*#__PURE__*/React.cloneElement(element, {\n      key: \"time-\".concat(index)\n    }))];\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(Wrapper, null, /*#__PURE__*/React.createElement(Grid, {\n      columns: this.state.dates.length,\n      rows: this.state.dates[0].length,\n      columnGap: this.props.columnGap,\n      rowGap: this.props.rowGap,\n      ref: el => {\n        this.gridRef = el;\n      }\n    }, this.renderFullDateGrid()));\n  }\n}\nexports.default = ScheduleSelector;\nScheduleSelector.defaultProps = {\n  selection: [],\n  selectionScheme: 'square',\n  numDays: 7,\n  minTime: 9,\n  maxTime: 23,\n  hourlyChunks: 1,\n  startDate: new Date(),\n  timeFormat: 'ha',\n  dateFormat: 'M/D',\n  columnGap: '4px',\n  rowGap: '4px',\n  selectedColor: _colors.default.blue,\n  unselectedColor: _colors.default.paleBlue,\n  hoveredColor: _colors.default.lightBlue,\n  onChange: () => {}\n};","map":{"version":3,"names":["React","_interopRequireWildcard","require","_styledComponents","_interopRequireDefault","_add_minutes","_add_hours","_add_days","_start_of_day","_is_same_minute","_format","_typography","_colors","_selectionSchemes","Wrapper","default","div","withConfig","displayName","componentId","Grid","props","columns","rows","columnGap","rowGap","GridCell","DateCell","selected","selectedColor","unselectedColor","hoveredColor","DateLabel","Subtitle","TimeText","Text","preventScroll","e","preventDefault","ScheduleSelector","Component","getDerivedStateFromProps","state","selectionStart","selectionDraft","selection","dates","computeDatesMatrix","startTime","startDate","minutesInChunk","Math","floor","hourlyChunks","d","numDays","currentDay","h","minTime","maxTime","c","push","constructor","cellToDate","Map","gridRef","renderDateCellWrapper","time","startHandler","handleSelectionStartEvent","Boolean","find","a","createElement","className","role","key","toISOString","onMouseDown","onMouseEnter","handleMouseEnterEvent","onMouseUp","handleMouseUpEvent","onTouchStart","onTouchMove","handleTouchMoveEvent","onTouchEnd","handleTouchEndEvent","renderDateCell","refSetter","dateCell","set","ref","renderTimeLabel","timeFormat","renderDateLabel","date","dateFormat","selectionType","isTouchDragging","selectionSchemeHandlers","linear","square","endSelection","bind","componentDidMount","document","addEventListener","forEach","value","passive","componentWillUnmount","removeEventListener","getTimeFromTouchEvent","event","touches","length","clientX","clientY","targetElement","elementFromPoint","cellTime","get","onChange","setState","updateAvailabilityDraft","selectionEnd","callback","newSelection","selectionScheme","nextDraft","Array","from","Set","filter","b","timeSelected","renderFullDateGrid","flattenedDates","numTimes","j","i","dateGridElements","map","index","splice","dayOfTimes","cloneElement","concat","element","render","el","defaultProps","Date","blue","paleBlue","lightBlue"],"sources":["/Users/zolyer/Documents/a1/naver_bidding/component-template/template/st_schedule_component/frontend/node_modules/react-schedule-selector/src/lib/ScheduleSelector.tsx"],"sourcesContent":["import * as React from 'react'\nimport styled from 'styled-components'\n\n// Import only the methods we need from date-fns in order to keep build size small\nimport addMinutes from 'date-fns/add_minutes'\nimport addHours from 'date-fns/add_hours'\nimport addDays from 'date-fns/add_days'\nimport startOfDay from 'date-fns/start_of_day'\nimport isSameMinute from 'date-fns/is_same_minute'\nimport formatDate from 'date-fns/format'\n\nimport { Text, Subtitle } from './typography'\nimport colors from './colors'\nimport selectionSchemes, { SelectionSchemeType, SelectionType } from './selection-schemes'\n\nconst Wrapper = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  user-select: none;\n`\n\nconst Grid = styled.div<{ columns: number; rows: number; columnGap: string; rowGap: string }>`\n  display: grid;\n  grid-template-columns: auto repeat(${props => props.columns}, 1fr);\n  grid-template-rows: auto repeat(${props => props.rows}, 1fr);\n  column-gap: ${props => props.columnGap};\n  row-gap: ${props => props.rowGap};\n  width: 100%;\n`\n\nexport const GridCell = styled.div`\n  place-self: stretch;\n  touch-action: none;\n`\n\nconst DateCell = styled.div<{\n  selected: boolean\n  selectedColor: string\n  unselectedColor: string\n  hoveredColor: string\n}>`\n  width: 100%;\n  height: 25px;\n  background-color: ${props => (props.selected ? props.selectedColor : props.unselectedColor)};\n\n  &:hover {\n    background-color: ${props => props.hoveredColor};\n  }\n`\n\nconst DateLabel = styled(Subtitle)`\n  @media (max-width: 699px) {\n    font-size: 12px;\n  }\n  margin: 0;\n  margin-bottom: 4px;\n`\n\nconst TimeText = styled(Text)`\n  @media (max-width: 699px) {\n    font-size: 10px;\n  }\n  text-align: right;\n  margin: 0;\n  margin-right: 4px;\n`\n\ntype PropsType = {\n  selection: Array<Date>\n  selectionScheme: SelectionSchemeType\n  onChange: (newSelection: Array<Date>) => void\n  startDate: Date\n  numDays: number\n  minTime: number\n  maxTime: number\n  hourlyChunks: number\n  dateFormat: string\n  timeFormat: string\n  columnGap: string\n  rowGap: string\n  unselectedColor: string\n  selectedColor: string\n  hoveredColor: string\n  renderDateCell?: (datetime: Date, selected: boolean, refSetter: (dateCellElement: HTMLElement) => void) => JSX.Element\n  renderTimeLabel?: (time: Date) => JSX.Element\n  renderDateLabel?: (date: Date) => JSX.Element\n}\n\ntype StateType = {\n  // In the case that a user is drag-selecting, we don't want to call this.props.onChange() until they have completed\n  // the drag-select. selectionDraft serves as a temporary copy during drag-selects.\n  selectionDraft: Array<Date>\n  selectionType: SelectionType | null\n  selectionStart: Date | null\n  isTouchDragging: boolean\n  dates: Array<Array<Date>>\n}\n\nexport const preventScroll = (e: TouchEvent) => {\n  e.preventDefault()\n}\n\nexport default class ScheduleSelector extends React.Component<PropsType, StateType> {\n  selectionSchemeHandlers: { [key: string]: (startDate: Date, endDate: Date, foo: Array<Array<Date>>) => Date[] }\n  cellToDate: Map<Element, Date> = new Map()\n  // documentMouseUpHandler: () => void = () => {}\n  // endSelection: () => void = () => {}\n  // handleTouchMoveEvent: (event: React.SyntheticTouchEvent<*>) => void\n  // handleTouchEndEvent: () => void\n  // handleMouseUpEvent: (date: Date) => void\n  // handleMouseEnterEvent: (date: Date) => void\n  // handleSelectionStartEvent: (date: Date) => void\n  gridRef: HTMLElement | null = null\n\n  static defaultProps: Partial<PropsType> = {\n    selection: [],\n    selectionScheme: 'square',\n    numDays: 7,\n    minTime: 9,\n    maxTime: 23,\n    hourlyChunks: 1,\n    startDate: new Date(),\n    timeFormat: 'ha',\n    dateFormat: 'M/D',\n    columnGap: '4px',\n    rowGap: '4px',\n    selectedColor: colors.blue,\n    unselectedColor: colors.paleBlue,\n    hoveredColor: colors.lightBlue,\n    onChange: () => {}\n  }\n\n  static getDerivedStateFromProps(props: PropsType, state: StateType): Partial<StateType> | null {\n    // As long as the user isn't in the process of selecting, allow prop changes to re-populate selection state\n    if (state.selectionStart == null) {\n      return {\n        selectionDraft: [...props.selection],\n        dates: ScheduleSelector.computeDatesMatrix(props)\n      }\n    }\n    return null\n  }\n\n  static computeDatesMatrix(props: PropsType): Array<Array<Date>> {\n    const startTime = startOfDay(props.startDate)\n    const dates: Array<Array<Date>> = []\n    const minutesInChunk = Math.floor(60 / props.hourlyChunks)\n    for (let d = 0; d < props.numDays; d += 1) {\n      const currentDay = []\n      for (let h = props.minTime; h < props.maxTime; h += 1) {\n        for (let c = 0; c < props.hourlyChunks; c += 1) {\n          currentDay.push(addMinutes(addHours(addDays(startTime, d), h), c * minutesInChunk))\n        }\n      }\n      dates.push(currentDay)\n    }\n    return dates\n  }\n\n  constructor(props: PropsType) {\n    super(props)\n\n    this.state = {\n      selectionDraft: [...this.props.selection], // copy it over\n      selectionType: null,\n      selectionStart: null,\n      isTouchDragging: false,\n      dates: ScheduleSelector.computeDatesMatrix(props)\n    }\n\n    this.selectionSchemeHandlers = {\n      linear: selectionSchemes.linear,\n      square: selectionSchemes.square\n    }\n\n    this.endSelection = this.endSelection.bind(this)\n    this.handleMouseUpEvent = this.handleMouseUpEvent.bind(this)\n    this.handleMouseEnterEvent = this.handleMouseEnterEvent.bind(this)\n    this.handleTouchMoveEvent = this.handleTouchMoveEvent.bind(this)\n    this.handleTouchEndEvent = this.handleTouchEndEvent.bind(this)\n    this.handleSelectionStartEvent = this.handleSelectionStartEvent.bind(this)\n  }\n\n  componentDidMount() {\n    // We need to add the endSelection event listener to the document itself in order\n    // to catch the cases where the users ends their mouse-click somewhere besides\n    // the date cells (in which case none of the DateCell's onMouseUp handlers would fire)\n    //\n    // This isn't necessary for touch events since the `touchend` event fires on\n    // the element where the touch/drag started so it's always caught.\n    document.addEventListener('mouseup', this.endSelection)\n\n    // Prevent page scrolling when user is dragging on the date cells\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.addEventListener) {\n        // @ts-ignore\n        dateCell.addEventListener('touchmove', preventScroll, { passive: false })\n      }\n    })\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mouseup', this.endSelection)\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.removeEventListener) {\n        // @ts-ignore\n        dateCell.removeEventListener('touchmove', preventScroll)\n      }\n    })\n  }\n\n  // Performs a lookup into this.cellToDate to retrieve the Date that corresponds to\n  // the cell where this touch event is right now. Note that this method will only work\n  // if the event is a `touchmove` event since it's the only one that has a `touches` list.\n  getTimeFromTouchEvent(event: React.TouchEvent<any>): Date | null {\n    const { touches } = event\n    if (!touches || touches.length === 0) return null\n    const { clientX, clientY } = touches[0]\n    const targetElement = document.elementFromPoint(clientX, clientY)\n    if (targetElement) {\n      const cellTime = this.cellToDate.get(targetElement)\n      return cellTime ?? null\n    }\n    return null\n  }\n\n  endSelection() {\n    this.props.onChange(this.state.selectionDraft)\n    this.setState({\n      selectionType: null,\n      selectionStart: null\n    })\n  }\n\n  // Given an ending Date, determines all the dates that should be selected in this draft\n  updateAvailabilityDraft(selectionEnd: Date | null, callback?: () => void) {\n    const { selectionType, selectionStart } = this.state\n\n    if (selectionType === null || selectionStart === null) return\n\n    let newSelection: Array<Date> = []\n    if (selectionStart && selectionEnd && selectionType) {\n      newSelection = this.selectionSchemeHandlers[this.props.selectionScheme](\n        selectionStart,\n        selectionEnd,\n        this.state.dates\n      )\n    }\n\n    let nextDraft = [...this.props.selection]\n    if (selectionType === 'add') {\n      nextDraft = Array.from(new Set([...nextDraft, ...newSelection]))\n    } else if (selectionType === 'remove') {\n      nextDraft = nextDraft.filter(a => !newSelection.find(b => isSameMinute(a, b)))\n    }\n\n    this.setState({ selectionDraft: nextDraft }, callback)\n  }\n\n  // Isomorphic (mouse and touch) handler since starting a selection works the same way for both classes of user input\n  handleSelectionStartEvent(startTime: Date) {\n    // Check if the startTime cell is selected/unselected to determine if this drag-select should\n    // add values or remove values\n    const timeSelected = this.props.selection.find(a => isSameMinute(a, startTime))\n    this.setState({\n      selectionType: timeSelected ? 'remove' : 'add',\n      selectionStart: startTime\n    })\n  }\n\n  handleMouseEnterEvent(time: Date) {\n    // Need to update selection draft on mouseup as well in order to catch the cases\n    // where the user just clicks on a single cell (because no mouseenter events fire\n    // in this scenario)\n    this.updateAvailabilityDraft(time)\n  }\n\n  handleMouseUpEvent(time: Date) {\n    this.updateAvailabilityDraft(time)\n    // Don't call this.endSelection() here because the document mouseup handler will do it\n  }\n\n  handleTouchMoveEvent(event: React.TouchEvent) {\n    this.setState({ isTouchDragging: true })\n    const cellTime = this.getTimeFromTouchEvent(event)\n    if (cellTime) {\n      this.updateAvailabilityDraft(cellTime)\n    }\n  }\n\n  handleTouchEndEvent() {\n    if (!this.state.isTouchDragging) {\n      // Going down this branch means the user tapped but didn't drag -- which\n      // means the availability draft hasn't yet been updated (since\n      // handleTouchMoveEvent was never called) so we need to do it now\n      this.updateAvailabilityDraft(null, () => {\n        this.endSelection()\n      })\n    } else {\n      this.endSelection()\n    }\n    this.setState({ isTouchDragging: false })\n  }\n\n  renderDateCellWrapper = (time: Date): JSX.Element => {\n    const startHandler = () => {\n      this.handleSelectionStartEvent(time)\n    }\n\n    const selected = Boolean(this.state.selectionDraft.find(a => isSameMinute(a, time)))\n\n    return (\n      <GridCell\n        className=\"rgdp__grid-cell\"\n        role=\"presentation\"\n        key={time.toISOString()}\n        // Mouse handlers\n        onMouseDown={startHandler}\n        onMouseEnter={() => {\n          this.handleMouseEnterEvent(time)\n        }}\n        onMouseUp={() => {\n          this.handleMouseUpEvent(time)\n        }}\n        // Touch handlers\n        // Since touch events fire on the event where the touch-drag started, there's no point in passing\n        // in the time parameter, instead these handlers will do their job using the default Event\n        // parameters\n        onTouchStart={startHandler}\n        onTouchMove={this.handleTouchMoveEvent}\n        onTouchEnd={this.handleTouchEndEvent}\n      >\n        {this.renderDateCell(time, selected)}\n      </GridCell>\n    )\n  }\n\n  renderDateCell = (time: Date, selected: boolean): JSX.Element => {\n    const refSetter = (dateCell: HTMLElement | null) => {\n      if (dateCell) {\n        this.cellToDate.set(dateCell, time)\n      }\n    }\n    if (this.props.renderDateCell) {\n      return this.props.renderDateCell(time, selected, refSetter)\n    } else {\n      return (\n        <DateCell\n          selected={selected}\n          ref={refSetter}\n          selectedColor={this.props.selectedColor}\n          unselectedColor={this.props.unselectedColor}\n          hoveredColor={this.props.hoveredColor}\n        />\n      )\n    }\n  }\n\n  renderTimeLabel = (time: Date): JSX.Element => {\n    if (this.props.renderTimeLabel) {\n      return this.props.renderTimeLabel(time)\n    } else {\n      return <TimeText>{formatDate(time, this.props.timeFormat)}</TimeText>\n    }\n  }\n\n  renderDateLabel = (date: Date): JSX.Element => {\n    if (this.props.renderDateLabel) {\n      return this.props.renderDateLabel(date)\n    } else {\n      return <DateLabel>{formatDate(date, this.props.dateFormat)}</DateLabel>\n    }\n  }\n\n  renderFullDateGrid(): Array<JSX.Element> {\n    const flattenedDates: Date[] = []\n    const numDays = this.state.dates.length\n    const numTimes = this.state.dates[0].length\n    for (let j = 0; j < numTimes; j += 1) {\n      for (let i = 0; i < numDays; i += 1) {\n        flattenedDates.push(this.state.dates[i][j])\n      }\n    }\n    const dateGridElements = flattenedDates.map(this.renderDateCellWrapper)\n    for (let i = 0; i < numTimes; i += 1) {\n      const index = i * numDays\n      const time = this.state.dates[0][i]\n      // Inject the time label at the start of every row\n      dateGridElements.splice(index + i, 0, this.renderTimeLabel(time))\n    }\n    return [\n      // Empty top left corner\n      <div key=\"topleft\" />,\n      // Top row of dates\n      ...this.state.dates.map((dayOfTimes, index) =>\n        React.cloneElement(this.renderDateLabel(dayOfTimes[0]), { key: `date-${index}` })\n      ),\n      // Every row after that\n      ...dateGridElements.map((element, index) => React.cloneElement(element, { key: `time-${index}` }))\n    ]\n  }\n\n  render(): JSX.Element {\n    return (\n      <Wrapper>\n        <Grid\n          columns={this.state.dates.length}\n          rows={this.state.dates[0].length}\n          columnGap={this.props.columnGap}\n          rowGap={this.props.rowGap}\n          ref={el => {\n            this.gridRef = el\n          }}\n        >\n          {this.renderFullDateGrid()}\n        </Grid>\n      </Wrapper>\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}